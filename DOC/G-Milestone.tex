\documentclass{article}

\title{Paladim - Milestone hand-in}
\author{}

\begin{document}
\maketitle
\newpage
\section{Parser implementation}
We've implemented the parser in mosmlyac using the grammar given in the GroupProject.pdf
as a starting point. To make the grammar suitable for LR(1)-parsing we made some
transformations of the grammar:
\begin{enumerate}
  \item We've made \texttt{if-then-else}-statements right-associative (simply by using
        \texttt{\%right}) in mosmlyac. This means that an \texttt{if} will bind to the
        closest \texttt{else}. This is the only transformation that actually change the
        language though it was necessary as the given grammar is ambiguous.
  \item All nonterminals of the form $X \rightarrow \alpha | X \alpha$ has been transformed
        to $X \rightarrow \alpha | \alpha X$. This has been done as SML-lists are most
        effectively constructed by using \texttt{::}.
  \item In the production $Exp \rightarrow Exp \; OP \; Exp$, $OP$ has been replaced with
        the actual operator-terminals. This was done to unhide operator precedence for
        mosmlyac.
        %This was done to let mosmlyac see what level of operator precedence there is
        %during the parsing of expressions of the form 
        %This was done to make mosmlyac generate a state for each precedence level of the
        %operators. Otherwise, it wouldn't be able to know what kind of operator (if any)
        %the preceding expression contained.$
\end{enumerate}
\section{Testing}
Most of the testing has been done using a small test-framework that we built. The framework
first parses all the files in the \texttt{DATA} folder. For each file, it outputs either
\texttt{FAIL} or \texttt{OK}, depending on whether any exceptions were raised. This tells us
that all the test files are parsed without exceptions, but not that they are parsed correctly.
For that, we need some syntax tree to compare against.

However, it would be far too much work to manually type syntax trees for each test file. We do
some tests that parse some code and compare the result against a hard-coded syntax tree, but
we have only done this for a few small pieces of code.

Again, the test framework outputs either \texttt{FAIL} or \texttt{OK} for each piece of code,
depending on whether the result matched the hard-coded syntax tree or not.

A nicer and easier way of testing would be to use the old LL1Parser as a reference. There are
a few problems with this, though. First, it would require that we kept an additional lexer
which used the old token type. Second, the LL1Parser can't parse everything in the Paladim
grammar -- there are contructions we wouldn't be able to test at all using this approach.

In addition to all of the above, we have verified that we can compile the Paladim binary and
use it to interpret and compile many of the programs in the \texttt{DATA} folder (all the
ones that do not need the other tasks to be completed), and that we get the correct output
from these programs.

\section{Ideas for other tasks}

\end{document}
