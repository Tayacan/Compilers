\documentclass{article}

\usepackage{listings}
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\lstdefinelanguage{Paladim}{
    morekeywords={program, function, procedure, var, begin, end, if, then, else, while},
    morekeywords={do, return, array, of, int, bool, char, and,  or, not, true, false},
    morecomment=[l]{//},
    morestring=[bd]',
    morestring=[bd]",
    sensitive=true,
}

\lstdefinelanguage{MIPS}{
    morekeywords={addi, add, sw, lw, j, beq, bne, slt, subi, sub, div, and, andi, or, ori},
    morecomment=[l]{\#},
    morestring=[bd]',
    morestring=[bd]",
    sensitive=false,
}

\lstdefinelanguage{SML}{
    morekeywords={ if, val, fun, let, in, end, then, else, andalso, orelse },
    morecomment=[s]{(*}{*)},
    morestring=[bd]',
    morestring=[bd]",
    sensitive=false,
}
\lstset{
    breaklines     = true,
    numbers        = left,
    stepnumber     = 1,
    numberstyle=\color{black},
    showstringspaces=false,
    language=SML,
    frame=single,
    basicstyle=\ttfamily\color{red!80!black},
      keywordstyle=\bfseries\color{blue},
      commentstyle=\color{green!40!black},
      identifierstyle=\ttfamily\color{black},
      stringstyle=\color{yellow!65!black},
}


\title{Paladim - Final hand-in}
\author{Ask Neve Gamby, Maya Saietz \& Christian Haase}

\begin{document}
\tableofcontents
\maketitle
\newpage
\section{Parser implementation}
We've implemented the parser in mosmlyac using the grammar given in the GroupProject.pdf
as a starting point. To make the grammar suitable for LR(1)-parsing we made some
transformations of the grammar:
\begin{enumerate}
  \item If-then-else-statements in the original grammar were ambiguous. This has been
        fixed by adding a pseudo-symbol \texttt{lower\_than\_else}, and giving it a
        lower precedence than the \texttt{TElse} token. This precedence rule is then
        used in the if-then-statement.
  \item All nonterminals of the form $X \rightarrow \alpha | X \alpha$ has been transformed
        to $X \rightarrow \alpha | \alpha X$. This has been done as SML-lists are most
        effectively constructed by using \texttt{::}.
  \item In the production $Exp \rightarrow Exp \; OP \; Exp$, $OP$ has been replaced with
        the actual operator-terminals. This was done to unhide operator precedence for
        mosmlyac.
\end{enumerate}

\subsection{Testing the parser}
Most of the testing has been done using a small test-framework that we built. The framework
first parses all the files in the \texttt{DATA} folder\footnote{We had to fix a syntax error in testTypeInference.pal -- the program didn't start with \texttt{program}}. For each file, it outputs either
\texttt{FAIL} or \texttt{OK}, depending on whether any exceptions were raised. This tells us
that all the test files are parsed without exceptions, but not that they are parsed correctly.
For that, we need some syntax tree to compare against.

However, it would be far too much work to manually type syntax trees for each test file. We do
some tests that parse some code and compare the result against a hard-coded syntax tree, but
we have only done this for a few small pieces of code.

Again, the test framework outputs either \texttt{FAIL} or \texttt{OK} for each piece of code,
depending on whether the result matched the hard-coded syntax tree or not.

To run the test framework, run the following commands (in the \texttt{SRC} folder):

\begin{verbatim}
$ make clean
$ make
$ mosml ParserTest.sml
\end{verbatim}

A nicer and easier way of testing would be to use the old LL1Parser as a reference. There are
a few problems with this, though. First, it would require that we kept an additional lexer
which used the old token type. Second, the LL1Parser can't parse everything in the Paladim
grammar -- there are contructions we wouldn't be able to test at all using this approach.

In addition to all of the above, we have verified that we can compile the Paladim binary and
use it to interpret and compile many of the programs in the \texttt{DATA} folder (all the
ones that do not need the other tasks to be completed), and that we get the correct output
from these programs.

\section{Integer multiplication and division and \texttt{or} and \texttt{not}}
Multiplication and division for integers and the missing boolean operators has been succesfully implemented in the rest of the compiler, that is for both interpretation and compilation. The first two has been implemented mostly by just imitating the implementation of addition and subtraction. E.g. in \texttt{Compiler.sml} the clauses in \texttt{compileExp} for subtraction and multiplication look very similar:
\begin{lstlisting}
    | compileExp( vtable, Minus(e1, e2, _), place ) =
        let val t1 = "minus1_" ^ newName()
            val c1 = compileExp(vtable, e1, t1)
            val t2 = "minus2_" ^ newName()
            val c2 = compileExp(vtable, e2, t2)
        in c1 @ c2 @ [Mips.SUB (place,t1,t2)]
        end

    (* Task 2: Integer multiplication and division implemented: *)

    | compileExp( vtable, Times(e1, e2, _), place ) =
        let val t1 = "times1_" ^ newName()
            val c1 = compileExp(vtable, e1, t1)
            val t2 = "times2_" ^ newName()
            val c2 = compileExp(vtable, e2, t2)
        in c1 @ c2 @ [Mips.MUL (place, t1, t2)]
        end
\end{lstlisting}
The boolean operator \texttt{or} was implemented similarly to \texttt{and}. The only difference in \texttt{Compiler.sml} is that we only have to check the second expression if the first expression is false, whereas for \texttt{and} we only check the second expression if the first is true. This was simply done by branching (and thus skipping the second evaluation), when the first is equal to 1 instead of 0.\newline
\texttt{not} was implemented in \texttt{Compile.sml} by simply XOR'ing the boolean value with 1, as \texttt{not x = x XOR 1}:
\begin{lstlisting}
    | compileExp( vtable, Not(e1, pos), place ) =
        let val t1 = "not_" ^ newName()
            val c1 = compileExp(vtable, e1, t1)
        in c1 @ [Mips.XORI (place, t1, "1")]
        end
\end{lstlisting}
Interpretation of the boolean operators was done by adding functions \texttt{evalOr} and \texttt{evalNot} equivalent to the existing \texttt{evalAnd}:
\begin{lstlisting}
fun evalOr (BVal (Log b1), BVal (Log b2), pos) = BVal (Log (b1 orelse b2))
  | evalOr (v1, v2, pos) =
        raise Error( "Or: argument types do not match. Arg1: " ^
                      pp_val v1 ^ ", arg2: " ^ pp_val v2, pos )

fun evalNot (BVal (Log b1), pos) = BVal (Log (not b1))
  | evalNot (v1, pos) =
        raise Error( "Not: argument: " ^ pp_val v1 ^ " must be boolean", pos )
\end{lstlisting}
and filling out the missing clauses in evalExp.
Interpretation of multiplication and division was done equivalent to that of addition and subtraction. First evaluate nested expressions and then let \texttt{evalBinop} do the actual evaluation of the relevant operation.
Type-checking of multiplication, division and \texttt{or} was done by using the code for type-checking addition and \texttt{and}. Type-checking \texttt{not}-expressions was only a little bit different from type-chekcing \texttt{and} and \texttt{or} as it takes only one argument:
\begin{lstlisting}
    | typeCheckExp ( vtab, AbSyn.Not (e,    pos), _ ) =
        let val e_new = typeCheckExp(vtab, e, UnknownType )
            val e_type= typeOfExp e_new
        in  if  typesEqual(BType Bool, e_type)
            then Not(e_new, pos)
            else raise Error("in type check and exp, one argument is not of bool type "^
                             pp_type e_type  ^ " at ", pos)
        end
\end{lstlisting}

\subsection{Testing the new operators}

\section{Type-checking of \texttt{read} and \texttt{new}}
%The idea is to use the ability to 'guess' the type of an expression by replacing \texttt{UnknownType} in calls to \texttt{typeCheckExp} with the acutal expected type whenever there is one. E.g. when checking an equality-expression we should use the checked type of the first expression as the expected type for the second, as the two should have the same type.

\subsection{Type-checking of \texttt{read}}
The return type of a \texttt{read()} call is determined by the context -- if it's assigned to some variable, for example, the return type is the type of that variable, or if it's used in an arithmethic expression, it must be an integer.

In order to determine this, we use the last parameter of \texttt{typeCheckExp}, the expected type. In any case where we know what the type of a sub-expression should be, we send that type along as a \texttt{KnownType}. For example, here's the updated code for type-checking a plus-expression:

\begin{lstlisting}
    | typeCheckExp(vtab, AbSyn.Plus (e1, e2, pos),_) =
        let val e1_new = typeCheckExp( vtab, e1, KnownType (BType Int))
            val e2_new = typeCheckExp( vtab, e2, KnownType (BType Int))
            val (tp1, tp2) = (typeOfExp e1_new, typeOfExp e2_new)
        in  if  typesEqual(BType Int, tp1) andalso typesEqual(BType Int, tp2)
            then Plus(e1_new, e2_new, pos)
            else raise Error(...)
        end
\end{lstlisting}

It's as simple as replacing each instance of \texttt{UnknownType} with \texttt{KnownType (BType Int)}.

Comparison operators (\texttt{=} and \texttt{<}) are slightly more complex -- here, we use the type of the first expression to determine the type of the second expression, like so:

\begin{lstlisting}
    | typeCheckExp (vtab,AbSyn.Equal(e1, e2, pos),_) =
        let val e1_new = typeCheckExp(vtab, e1, UnknownType)
            val e2_new = typeCheckExp(vtab, e2, KnownType (typeOfExp e1_new) )
            val (tp1, tp2) = (typeOfExp e1_new, typeOfExp e2_new)
            (* check that tp1 is not an array type *)
            val () = case tp1 of
                       Array _ => raise Error(...)
                     | _ => ()
        in  if  typesEqual(tp1, tp2)
            then Equal(e1_new, e2_new, pos)
            else raise Error(...)
        end
\end{lstlisting}

Here, the first expression still has an unknown type, and so cannot be a \texttt{read}-call.

\subsection{Type-checking of \texttt{new}}
The type-checking of \texttt{new} is done as was recommended in the comments in the code:

\begin{enumerate}
    \item Type-check all arguments with expected type \texttt{KnownType (BType Int)}
    \item Extract a list of all the types, using \texttt{map typeOfExp}.
    \item Check that all arguments are integers, and that there is at least one argument. If not, throw appropriate errors.
    \item If all of the above succeeds, return the type-ckecked FunApp.
\end{enumerate}

The code looks like this:
\begin{lstlisting}
  | typeCheckExp ( vtab, AbSyn.FunApp ("new", args, pos), etp ) =
  ( case expectedBasicType etp of
      SOME btp => let val new_args = map (fn a => typeCheckExp (vtab,a,KnownType (BType Int))) args
                      val arg_tps = map typeOfExp new_args
                  in if not (foldl (fn (t,b) => (b andalso
                             typesEqual(BType Int, t))) true arg_tps)
                     then raise Error(...)
                     else if length new_args > 0
                          then FunApp ( ("new", (arg_tps, SOME (Array(length new_args, btp))))
                                      , new_args, pos)
                          else raise Error(...)
                  end
    | NONE     => raise Error(...) )
\end{lstlisting}

In an ideal world, type-checking all arguments with integer as the expected type should be enough to ensure that they are all integers, but \texttt{typeCheckExp} only uses the expected type in cases where it's unclear what type an expression should have, such as \texttt{read}-calls. This means that \texttt{typeCheckExp(vtab, somePlusExpression, KnownType(BType Bool))} would not fail, even though a plus expression is always an integer type.

\section{Array indexing}
\subsection{Type checking}
Type checking of an array index is simply done by mapping a function that type checks an expression and raises an error if it is not of type \texttt{int} on the list of the given indexes. It also checks that the indexing is full, i.e. the rank of the array equals the length of the list of indexes.
The added clause to the function \texttt{typeCheckExp} is:
\begin{lstlisting}
    | typeCheckExp( vtab, AbSyn.LValue( AbSyn.Index(id, inds), pos ), _ ) =
       (case SymTab.lookup id vtab of
          NONE => raise Error("in type check indexed array, id "^id^" not in VTab, at ", pos)
        | SOME (tp as (Array (rank, e_type))) =>
          let val new_inds = map (fn exp =>
            let val new_i = typeCheckExp(vtab, exp, KnownType (BType Int))
            in  if typesEqual(BType Int, typeOfExp new_i)
                then new_i
                else raise Error("in type check one index in indexed array not"^
                                 "an int-expression, at ", pos)
            end inds
          in
            if rank > 0 andalso rank = length inds
            then LValue(Index((id, tp), new_inds), pos)
            else raise Error("in type check indexed array full indexing "^
                             "expected, at ", pos)
          end
        | _ => raise Error("Type check error: can only index "^
                           "into arrays, at ", pos)
       )
\end{lstlisting}
\subsection{Code generation}

\section{Call-by-value-result semantics for procedures}
To implement call-by-value-result semeantics, a slightly different procedure was necessary
for the interpreter and the compiler. 
\subsection{Interpreter}
In the interpreter, the use of the SML references,
which is stored in the symbol table, allowed for dirrect manipulation of the outer symbol table inside the called function,
since the old symbol table was parsed allong as a parameter to callFun, which would use a copied symbol table for its inner statements.
This allowed us to simply update the references for those expressions, which we could identify as simply being a single identifier.
While it did require some pattern matching, to check the correct type of expression, and extracting informatin the right way
from the symbol tables, it was relatively straitforward.
% inner
\subsection{Compilation of procedures}
The generated code starts by moving the bound parameters into temporary registers. Our addition to the code
does exactly the opposite. After the code that makes up the body of the procedure, we add Mips.MOVE-instructions
to move the values, not from \texttt{reg} to \texttt{vname}, but from \texttt{vname} to \texttt{reg}.

We have added our code to the list of instructions given to the register allocater, because it uses the same
registers as \texttt{argcode} -- When the symbolic registers in \texttt{argcode} are assigned, we want it to
use the same registers for moving the other way.

% outer

\end{document}
