{%
open AbSyn;

fun packLiteral f v = Literal (BVal (f (#1 v)) ,#2 v)
fun opGen op p (e1,e2) = op (e1,e2,p)
%}

/* keywords */
%token <Pos> TProgram TFunction TProcedure
%token <Pos> TVar TBegin TEnd
%token <Pos> TIf TThen TElse
%token <Pos> TWhile TDo TReturn

/* type keywords */
%token <Pos> TArray TOf
%token <Pos> TInt TChar TBool

/* punctuation */
%token <Pos> TSemi TColon TComma TAssign

/* operators */
%token <Pos> TPlus TMinus TTimes TSlash
%token <Pos> TEq TLess TAnd

/* parentheses */
%token <Pos> TLParen TRParen
%token <Pos> TLCurly TRCurly
%token <Pos> TLBracket TRBracket

/* identifiers */
%token <Ident * Pos> TId

/* literals */
%token <int * Pos> TNLit
%token <bool * Pos> TBLit
%token <char * Pos> TCLit
%token <string * Pos> TSLit

%token <Pos> TEOF

/* main parser */
%start Prog
%type <Prog> Prog

%%

Prog:
    TProgram TId TSemi Fundecs TEOF { $4 }
;

Fundecs:
    Fundec Fundecs { $1 :: $2 }
  | Fundec         { [$1] }
;

Fundec:
    TFunction  TId TLParen PDecl TRParen TColon Type Block TSemi { Func ($7,#1 $2,$4,$8,$1) }
  | TProcedure TId TLParen PDecl TRParen             Block TSemi { Proc (#1 $2,$4,$6,$1)    }
;

Block:
    DBlock SBlock { Block($1,$2) }
;

DBlock:
    TVar Decs   { $2 }
  | /* empty */ { [] }
;

SBlock:
    TBegin StmtSeq TSemi TEnd { $2   }
  | Stmt                      { [$1] }
;

StmtSeq:
    Stmt TSemi StmtSeq { $1 :: $3 }
  | Stmt               { [$1] }
;

Stmt:
    TId TLParen CallParams TRParen  { ProcCall (#1 $1, $3, #2 $1) }
  /* THIS IS BAD. MAKE IT NOT AMBIGUOUS!!1! */
  | TIf Exp TThen Block             { IfThEl   ($2, $4, Block([],[]), $1) }
  | TIf Exp TThen Block TElse Block { IfThEl   ($2, $4, $6, $1) }
  | TWhile Exp TDo Block            { While    ($2, $4, $1) }
  | TReturn Ret                     { Return   ($2, $1) }
  | LVal TAssign Exp                { Assign   (#1 $1, $3, #2 $1) }
;

LVal:
    TId                          { (Var   (#1 $1),     #2 $1) }
  | TId TLBracket Exps TRBracket { (Index (#1 $1, $3), #2 $1) }
;

Ret:
    Exp         { SOME $1 }
  | /* empty */ { NONE    }
;

Exp:
    TNLit                          { packLiteral Num $1 }
  | TBLit                          { packLiteral Log $1 }
  | TCLit                          { packLiteral Chr $1 }
  | TSLit                          { StrLit $1 }
  | TLCurly Exps TRCurly           { ArrLit ($2,$1) }
  | LVal                           { LValue $1 }
  | TNot Exp                       { Not($2,$1) }
  | Exp Op Exp                     { $2 ($1,$3)  }
  | TLParen Exp TRParen            { $2 }
  | TId TLParen CallParams TRParen { FunApp(#1 $1,$3,#2 $1) }
;

Op:
    TPlus  { opGen Plus $1 }
    TMinus { opGen Minus $1 }
    TTimes { opGen Times $1 }
    TDiv   { opGen Div $1 }
    TEqual { opGen Equal $1 }
    TLess  { opGen Less $1 }
    TAnd   { opGen And $1 }
    TOr    { opGen Or $1 }
;



Exps:
    Exp  TComma Exps { $1 :: $2 }
  | Exp              { [$1] }
;

CallParams:
    Exps        { $1 }
  | /* empty */ { [] }
;

PDecl:
    Params      { $1 }
  | /* empty */ { [] }
;

Params:
    Dec TSemi Params { $1 :: $3 }
  | Dec              { [$1] }
;

Dec:
    TId TColon Type { Dec(#1 $1, $3, #2 $1) }
;

Decs:
   Dec Decs  { $1 :: $2 }
 | Dec TSemi { [$1] }
;

Type:
   TInt { Int $1 }
 | TBool { Bool $1 }
 | TChar { Char $1 }
 | TArray TOf Type { Array($3,$1) }
;
