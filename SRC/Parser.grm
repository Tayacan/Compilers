{%
open AbSyn;

fun packLiteral f v = Literal (BVal (f (#1 v)) ,#2 v)
%}

%token <Pos> TProgram TFunction TProcedure
%token <Pos> TVar TBegin TEnd
%token <Pos> TIf TThen TElse
%token <Pos> TWhile TDo TReturn

%token <Pos> TArray TOf
%token <Pos> TInt TChar TBool

%token <Pos> TSemi TColon TComma TAssign

%token <Pos> TPlus TMinus TTimes TSlash
%token <Pos> TEq TLess TAnd

%token <Pos> TLParen TRParen
%token <Pos> TLCurly TRCurly
%token <Pos> TLBracket TRBracket

%token <Ident * Pos> TId

%token <int * Pos> TNLit
%token <bool * Pos> TBLit
%token <char * Pos> TCLit
%token <string * Pos> TSLit

%token <Pos> TEOF

%start Prog
%type <Prog> Prog

%%

Prog:
    TProgram TId TSemi Fundecs TEOF { $4 }
;

Fundecs:
    Fundec Fundecs { $1 :: $2 }
  | Fundec         { [$1] }
;

Fundec:
    TFunction  TId TLParen PDecl TRParen TColon Type Block TSemi { Func ($7,#1 $2,$4,$8,$1) }
  | TProcedure TId TLParen PDecl TRParen             Block TSemi { Proc (#1 $2,$4,$6,$1)    }
;

Block:
    DBlock SBlock { Block($1,$2) }
;

DBlock:
    TVar Decs   { $2 }
  | /* empty */ { [] }
;

SBlock:
    TBegin StmtSeq TSemi TEnd { $2   }
  | Stmt                      { [$1] }
;

StmtSeq:
    Stmt TSemi StmtSeq { $1 :: $3 }
  | Stmt               { [$1] }
;

Stmt:
    TId TLParen CallParams TRParen  { ProcCall (#1 $1, $3, #2 $1) }
  /* THIS IS BAD. MAKE IT NOT AMBIGUOUS!!1! */
  | TIf Exp TThen Block             { IfThEl   ($2, $4, Block([],[]), $1) }
  | TIf Exp TThen Block TElse Block { IfThEl   ($2, $4, $6, $1) }
  | TWhile Exp TDo Block            { While    ($2, $4, $1) }
  | TReturn Ret                     { Return   ($2, $1) }
  | LVal TAssign Exp                { Assign   (#1 $1, $3, #2 $1) }
;

LVal:
    TId                          { (Var   (#1 $1),     #2 $1) }
  | TId TLBracket Exps TRBracket { (Index (#1 $1, $3), #2 $1) }
;

Ret:
    Exp         { SOME $1 }
  | /* empty */ { NONE    }
;

Exp:
    TNLit { packLiteral Num $1 }
  | TBLit { packLiteral Log $1 }
  | TCLit { packLiteral Chr $1 }
  | TSLit { StrLit $1 }
  | TLCurly Exps TRCurly { ArrLit $2 }
  | LVal  { LValue $1 }
  | 
;

Exps:
    /* TODO */
    /* Should include the position of the first Expr */
;

PDecl:
    /* TODO */
;

Type:
    /* TODO */
;
